<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>数据分析之SQL | danny's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.1.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">数据分析之SQL</h1><a id="logo" href="/.">danny's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">数据分析之SQL</h1><div class="post-meta">2020-12-05<span> | </span><span class="category"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">SQL的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E5%BF%85%E9%A1%BB%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">SQL必须要掌握的语法知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%9F%BA%E6%9C%AC"><span class="toc-number">2.1.</span> <span class="toc-text">最基本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B8%B8%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">最常用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6"><span class="toc-number">2.3.</span> <span class="toc-text">基础进阶</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B8%8E%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">应用与知识点</span></a></li></ol></div></div><div class="post-content"><h2 id="SQL的基本概念"><a href="#SQL的基本概念" class="headerlink" title="SQL的基本概念"></a>SQL的基本概念</h2><ul>
<li>SQL: Structured Query Language，结构化查询语言，用于访问与处理数据库的标准的计算机语言。</li>
<li>数据库程序有：MS Access、DB2、MS SQL Server、MySQL、Oracle、Informix、Sybase等。</li>
<li>SQL对大小写不敏感。</li>
<li>SQL的功能（增删改查、分组、聚合、排序、去重）<ul>
<li>创建新的数据库、表、存储过程、视图</li>
<li>删除记录</li>
<li>插入新的记录、更新数据</li>
<li>查询</li>
<li>设置表、存储过程和视图的权限</li>
</ul>
</li>
<li>SQL：数据操作语言DML + 数据定义语言DDL<ul>
<li>DML: 插入、删除、更新与查询指令。<ol>
<li>insert into</li>
<li>delete</li>
<li>update</li>
<li>select</li>
</ol>
</li>
<li>DDL: 创建或删除表格，定义索引键，规定表之间的链接，以及施加表的约束。<ol>
<li>create database  创建新数据库</li>
<li>alter database  修改数据库</li>
<li>create table  创建新数据表</li>
<li>alter table  变更数据表</li>
<li>drop table  删除数据表</li>
<li>create index  创建索引</li>
<li>drop index  删除索引</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="SQL必须要掌握的语法知识"><a href="#SQL必须要掌握的语法知识" class="headerlink" title="SQL必须要掌握的语法知识"></a>SQL必须要掌握的语法知识</h2><h3 id="最基本"><a href="#最基本" class="headerlink" title="最基本"></a>最基本</h3><ul>
<li>选择：select</li>
<li>连接：join/ left join/ right join/ union<h3 id="最常用"><a href="#最常用" class="headerlink" title="最常用"></a>最常用</h3></li>
<li>去重：distinct</li>
<li>筛选：having/ where</li>
<li>聚合：max/ min/ sum/ count + group by</li>
<li>排序：order by/ sort by</li>
<li>条件：cse when… end</li>
<li>字符串：substr/ concat/ split<h3 id="基础进阶"><a href="#基础进阶" class="headerlink" title="基础进阶"></a>基础进阶</h3></li>
<li>日期函数：to_date/ datediff</li>
<li>分组排序：row_number()</li>
<li>取百分比：percentile</li>
</ul>
<h2 id="应用与知识点"><a href="#应用与知识点" class="headerlink" title="应用与知识点"></a>应用与知识点</h2><p>（来源：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/ta/sql">牛客网SQL题目</a>）</p>
<ul>
<li><p>条件：where与having<br>“Where” 是一个约束声明，使用Where来约束来之数据库的数据，Where是在结果返回之前起作用的，且Where中不能使用聚合函数。<br>“Having”是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在Having中可以使用聚合函数。</p>
</li>
<li><p>去掉最大最小，算平均值<br>题：查找排除最大、最小salary之后的当前(to_date = ‘9999-01-01’ )员工的平均工资avg_salary。<br>方法1：not in 判断</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(salary) <span class="keyword">as</span> avg_salary </span><br><span class="line"><span class="keyword">from</span> salaries</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">to_date</span> = <span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line"><span class="keyword">and</span> salary <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">max</span>(salary) <span class="keyword">from</span> salaries <span class="keyword">where</span> <span class="keyword">to_date</span> = <span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">and</span> salary <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">min</span>(salary) <span class="keyword">from</span> salaries <span class="keyword">where</span> <span class="keyword">to_date</span> = <span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>方法2：大于、小于判断<br>where条件 后面不能跟分组函数，因为执行顺序是先执行where 之后才执行分组，还没有分组的时候是无法运行min,max,avg，sum,count这类函数的！<br>错误写法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">from</span> salaries</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">to_date</span>=<span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line"><span class="keyword">and</span> salary &lt; <span class="keyword">max</span>(salary)</span><br><span class="line"><span class="keyword">and</span> salary &gt; <span class="keyword">min</span>(salary) </span><br></pre></td></tr></table></figure>
<p>正确写法，将where后面的分组函数改成子查询！</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(salary) <span class="keyword">as</span> avg_salary </span><br><span class="line"><span class="keyword">from</span> salaries</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">to_date</span> = <span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line"><span class="keyword">and</span> salary &lt; (<span class="keyword">select</span> <span class="keyword">max</span>(salary) <span class="keyword">from</span> salaries <span class="keyword">where</span> <span class="keyword">to_date</span> = <span class="string">&#x27;9999-01-01&#x27;</span>)</span><br><span class="line"><span class="keyword">and</span> salary &gt; (<span class="keyword">select</span> <span class="keyword">min</span>(salary) <span class="keyword">from</span> salaries <span class="keyword">where</span> <span class="keyword">to_date</span> = <span class="string">&#x27;9999-01-01&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入多条数据<br>方法一：利用VALUES(value1, value2, …), (value1, value2, …),…(value1, value2, …),</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> actor</span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;PENELOPE&#x27;</span>, <span class="string">&#x27;GUINESS&#x27;</span>, <span class="string">&#x27;2006-02-15 12:34:33&#x27;</span>),(<span class="number">2</span>, <span class="string">&#x27;NICK&#x27;</span>, <span class="string">&#x27;WAHLBERG&#x27;</span>, <span class="string">&#x27;2006-02-15 12:34:33&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>方法二：利用 UNION SELECT 批量插入</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> actor</span><br><span class="line"><span class="keyword">select</span> <span class="number">1</span>, <span class="string">&#x27;PENELOPE&#x27;</span>, <span class="string">&#x27;GUINESS&#x27;</span>, <span class="string">&#x27;2006-02-15 12:34:33&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">2</span>, <span class="string">&#x27;NICK&#x27;</span>, <span class="string">&#x27;WAHLBERG&#x27;</span>, <span class="string">&#x27;2006-02-15 12:34:33&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>判断值为奇偶数<br>题：查找employees表所有emp_no为奇数，且last_name不为Mary(注意大小写)的员工信息，并按照hire_date逆序排列。<br>1、取余%</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> emp_no % <span class="number">2</span> = <span class="number">1</span> </span><br><span class="line"><span class="keyword">and</span> last_name != <span class="string">&#x27;Mary&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> hire_date <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<p>2、位运算</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> employees e</span><br><span class="line"><span class="keyword">where</span> e.emp_no &amp; <span class="number">1</span> = <span class="number">1</span> <span class="keyword">and</span> e.last_name != <span class="string">&#x27;Mary&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> e.hire_date <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<p>计算机中奇数=XXXXXXX1,偶数位=XXXXXXX0<br>奇&amp;1（00000001）=1<br>偶&amp;1（00000001）=0<br>计算机中&amp;运算的性能要高于四则运算</p>
</li>
<li><p>多张表格<br>题1、获取所有非manager的员工的emp_no。一张表是所有雇员employees，一张表是已分配部门员工dept_manager。<br>not in在实际使用中，因为not in会转化成多表连接，而且不使用索引，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp_no <span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> emp_no <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> emp_no <span class="keyword">from</span> dept_manager</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在这里，觉得还是用left_join代替会好一点。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.emp_no </span><br><span class="line"><span class="keyword">from</span> employees <span class="keyword">as</span> e <span class="keyword">left</span> <span class="keyword">join</span> dept_manager <span class="keyword">as</span> d </span><br><span class="line"><span class="keyword">on</span> e.emp_no = d.emp_no</span><br><span class="line"><span class="keyword">where</span> d.dept_no <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>题2、查找所有已经分配部门的员工的last_name和first_name以及dept_no(请注意输出描述里各个列的前后顺序)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> last_name, first_name, dept_no </span><br><span class="line"><span class="keyword">from</span> employees <span class="keyword">left</span> <span class="keyword">join</span> dept_emp</span><br><span class="line"><span class="keyword">on</span> employees.emp_no = dept_emp.emp_no</span><br><span class="line"><span class="keyword">where</span> dept_emp.dept_no <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> last_name, first_name, dept_no </span><br><span class="line"><span class="keyword">from</span> employees, dept_emp </span><br><span class="line"><span class="keyword">where</span> dept_emp.emp_no = employees.emp_no;</span><br></pre></td></tr></table></figure>
<p>题3、三张表，使用子查询的方式找出属于Action分类的所有电影对应的title,description？<br>1、in子查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> f.title, f.description <span class="keyword">from</span> film <span class="keyword">as</span> f</span><br><span class="line"><span class="keyword">where</span> f.film_id <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> fc.film_id <span class="keyword">from</span> film_category <span class="keyword">as</span> fc</span><br><span class="line">    <span class="keyword">where</span> fc.category_id <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">select</span> c.category_id <span class="keyword">from</span> <span class="keyword">category</span> <span class="keyword">as</span> c</span><br><span class="line">        <span class="keyword">where</span> c.name = <span class="string">&#x27;Action&#x27;</span></span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>2、join连接查询<br>注意：<br>inner join 两边表同时有对应的数据，即任何一边缺失数据就不显示。<br>left join 会读取左边数据表的全部数据，即便右边表无对应数据。<br>right join 会读取右边数据表的全部数据，即便左边表无对应数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> f.title, f.description <span class="keyword">from</span> film <span class="keyword">as</span> f </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> film_category <span class="keyword">as</span> fc <span class="keyword">on</span> f.film_id = fc.film_id</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">category</span> <span class="keyword">as</span> c <span class="keyword">on</span> c.category_id = fc.category_id</span><br><span class="line"><span class="keyword">where</span> c.name = <span class="string">&#x27;Action&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>on与where用法区别<br>都是表条件<br>on：就是与join连用，条件是在生成临时表时使用的条件。<br>where：用于规定选择的标准，如需有条件地从表中选取数据，可将 where子句添加到 select语句。</p>
</li>
</ul>
<p>3、直接用逗号并列查询<br>三个限定条件分别是 f.film_id = fc.film_id、fc.category_id = c.category_id、c.name = ‘Action’。 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> f.title, f.description </span><br><span class="line"><span class="keyword">from</span> film f, film_category fc, <span class="keyword">category</span> c</span><br><span class="line"><span class="keyword">where</span> f.film_id = fc.film_id </span><br><span class="line"><span class="keyword">and</span> fc.category_id = c.category_id </span><br><span class="line"><span class="keyword">and</span> c.name = <span class="string">&#x27;Action&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>去重<br>题1、找出所有员工当前(to_date=’9999-01-01’)具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示。<br>distinct：直接是去重的功能</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> salary <span class="keyword">from</span> salaries</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">to_date</span>=<span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<p>group by：相同的合并为一组</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> salaries </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">to_date</span>=<span class="string">&#x27;9999-01-01&#x27;</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> salary </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<p>题2、从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。<br>注意对于重复的emp_no进行忽略(即emp_no重复的title不计算，title对应的数目t不增加)。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> title, <span class="keyword">count</span>(<span class="keyword">distinct</span> emp_no) <span class="keyword">as</span> t </span><br><span class="line"><span class="keyword">from</span> titles</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> title <span class="keyword">having</span> t &gt;= <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>对于distinct与group by的使用选择<br>1、当对系统的性能高并数据量大时使用group by<br>2、当对系统的性能不高时使用数据量少时两者皆可<br>3、尽量使用group by。</p>
</li>
<li><p>取n条数据<br>方法一：limit<br>limit m,n : 表示从第m+1条开始，取n条数据；<br>limit n ：是limit(0,n)的缩写，表示从第1条开始，取n条数据。<br>方法二：利用 limit 和 offset 关键字。limit 后的数字代表返回几条记录，offset 后的数字代表从第几条记录开始返回（第一条记录序号为0），也可理解为跳过多少条记录后开始返回。</p>
</li>
</ul>
<p>题1、查找入职员工时间排名倒数第三的员工所有信息，为了减轻入门难度，目前所有的数据里员工入职的日期都不是同一天。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> hire_date <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">2</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>分页查询，每页5条数据，查找第二页的所有数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">limit</span> <span class="number">5</span> <span class="keyword">offset</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>题2、获取当前（to_date=’9999-01-01’）薪水第二多的员工的emp_no以及其对应的薪水salary。<br>获取第二名的数据：去重、排序，取第二条的数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp_no, salary <span class="keyword">from</span> salaries</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">to_date</span> = <span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line"><span class="keyword">and</span> salary = (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> salary <span class="keyword">from</span> salaries</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>表A包含表B，取补集<br>使用含有关键字exists查找未分配具体部门的员工的所有信息。<br>exists：对外表用loop逐条查询，每次查询都会查看exists的条件语句，当 exists里的条件语句能够返回记录行时(只要能返回)，条件就为真，返回当前loop到的这条记录；反之如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为 false。<br>exists强调的是是否返回结果集，不要求知道返回什么。只要返回了字段，就是真。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> emp_no <span class="keyword">from</span> dept_emp </span><br><span class="line">    <span class="keyword">where</span> dept_emp.emp_no = employees.emp_no</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> emp_no <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> emp_no <span class="keyword">from</span> dept_emp</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>什么时候用EXISTS，什么时候用IN？<br>主表为employees，从表为dept_emp，在主表和从表都对关联的列emp_no建立索引的前提下：<br>当主表比从表大时，IN查询的效率较高；<br>当从表比主表大时，EXISTS查询的效率较高；<br>原因如下：<br>in是先执行子查询，得到一个结果集，将结果集代入外层谓词条件执行主查询，子查询只需要执行一次；<br>exists是先从主查询中取得一条数据，再代入到子查询中，执行一次子查询，判断子查询是否能返回结果，主查询有多少条数据，子查询就要执行多少次。</p>
</li>
<li><p>拼接<br>group_concat() 函数：返回X的非null值的连接后的字符串，每个元素连接的顺序是随机的。<br>group_concat(X)，如果省略了Y，“，”将作为默认的分隔符。<br>group_concat(X,Y)，如果给出了参数Y，将会在每个X之间用Y作为分隔符。</p>
</li>
</ul>
<p>题1、按照dept_no进行汇总，属于同一个部门的emp_no按照逗号进行连接，结果给出dept_no以及连接出的结果employees。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_no, <span class="keyword">group_concat</span>(emp_no) <span class="keyword">as</span> employees </span><br><span class="line"><span class="keyword">from</span> dept_emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_no</span><br></pre></td></tr></table></figure>
<p>题2、将employees表中的所有员工的last_name和first_name通过(‘)连接起来。<br>(sqlite不支持concat，请用||实现，mysql支持concat)。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(last_name, <span class="string">&quot;&#x27;&quot;</span>, first_name) <span class="keyword">as</span> <span class="keyword">name</span> <span class="keyword">from</span> employees</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> last_name || <span class="string">&quot;&#x27;&quot;</span> || first_name <span class="keyword">as</span> <span class="keyword">name</span> <span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure>
<p>题3、将employees表的所有员工的last_name和first_name拼接起来作为Name，中间以一个空格区分。<br>MySQL、SQL Server、Oracle等数据库支持concat方法， </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">CONCAT</span>(<span class="keyword">CONCAT</span>(last_name,<span class="string">&quot; &quot;</span>),first_name) <span class="keyword">as</span> <span class="keyword">name</span>  <span class="keyword">from</span> employees</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">CONCAT</span>(last_name,<span class="string">&quot; &quot;</span>,first_name) <span class="keyword">as</span> <span class="keyword">name</span>  <span class="keyword">from</span> employees</span><br></pre></td></tr></table></figure>
<p>而SQLite数据库只支持用连接符号”||”来连接字符串。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> last_name||<span class="string">&quot; &quot;</span>||first_name <span class="keyword">as</span> <span class="keyword">name</span>  <span class="keyword">from</span> employees</span><br></pre></td></tr></table></figure>

<ul>
<li>concat和group_concat的区别<br>concat和group_concat都是用在sql语句中做拼接使用的，但是两者使用的方式不尽相同，<br>concat是针对以行数据做的拼接，<br>而group_concat是针对列做的数据拼接，且group_concat自动生成逗号。</li>
</ul>
<ol>
<li>concat的使用<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="keyword">id</span>, <span class="string">&quot;,&quot;</span>, classId) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li>
<li>group_concat的使用：group_concat一般和group by 结合使用比较多<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">group_concat</span>(username) <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> classId;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>取字段的后2个字母排序<br>substr()函数<br>substr(要截取的字符串，起始位置，长度）<br>起始位置：要截取的字符串的起始位置（注意：字符串的第一个字符的索引是1）。<br>值为正时从字符串开始位置 开始计数，值为负时从字符串结尾位置开始计数。<br>长度：截取字符串的长度。<br>题目：获取Employees中的first_name，查询按照first_name最后两个字母，按照升序进行排列。<br>substr(X,Y,Z)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> first_name <span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">substr</span>(first_name, <span class="keyword">length</span>(first_name)<span class="number">-1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>substr(X,Y)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> first_name <span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">substr</span>(first_name, <span class="number">-2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算字段中字符出现的次数<br>查找字符串’10,A,B’ 中逗号’,’出现的次数cnt。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(</span><br><span class="line">    (<span class="keyword">length</span>(<span class="string">&quot;10,A,B&quot;</span>) - </span><br><span class="line">    <span class="keyword">length</span>(<span class="keyword">replace</span>(<span class="string">&quot;10,A,B&quot;</span>, <span class="string">&quot;,&quot;</span>, <span class="string">&quot;&quot;</span>))) / </span><br><span class="line">    <span class="keyword">length</span>(<span class="string">&quot;,&quot;</span>), <span class="number">0</span>) </span><br><span class="line"><span class="keyword">as</span> cnt</span><br></pre></td></tr></table></figure>
<p>length()：统计字符串长度<br>replace(目标字符串，“需要替换的子串”，“用于替换子串的字符串”）<br>将，替换为空，字符串缩短的长度就是，号的个数。<br>再除以替换的字串的长度，本题中此步可省略，若子串长度大于1则不可省。</p>
</li>
<li><p>创建外键约束<br>在audit表上创建外键约束，其emp_no对应employees_test表的主键id。<br>(以下2个表已经创建了)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees_test(</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">NAME</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">AGE <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">ADDRESS <span class="built_in">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">SALARY <span class="built_in">REAL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">audit</span>(</span><br><span class="line">EMP_no <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">create_date datetime <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">audit</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">audit</span> (</span><br><span class="line">    emp_no <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    create_date datetime <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">foreign</span> <span class="keyword">key</span>(emp_no) <span class="keyword">references</span> employees_test(<span class="keyword">id</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>强制索引查询<br>针对salaries表emp_no字段创建索引idx_emp_no，查询emp_no为10005, 使用强制索引。<br>Mysql，使用 force index 语句进行强制索引查询，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_emp_no <span class="keyword">on</span> salaries(emp_no);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> salaries <span class="keyword">force</span> <span class="keyword">index</span> (idx_emp_no) </span><br><span class="line"><span class="keyword">where</span> emp_no = <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>
<p>SQLite中，使用 INDEXED BY 语句进行强制索引查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> salaries indexed <span class="keyword">by</span> idx_emp_no <span class="keyword">where</span> emp_no = <span class="number">10005</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>插入insert数据</p>
<ul>
<li>insert into tablename values()：插入数据,如果主键重复，则报错</li>
<li>insert repalce into tablename values()：插入替换数据,如果存在主键或unique数据则替换数据</li>
<li>insert ignore into tablename values()：如果存在数据,则忽略。<br>这里指的存在表示的是unique属性的列值存在的情况下，unique表示键值唯一。</li>
</ul>
</li>
</ul>
</div><div class="tags"><a href="/tags/SQL/"><i class="fa fa-tag"></i>SQL</a></div><div class="post-nav"><a class="pre" href="/2020/12/07/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%E9%87%91%E8%9E%8D%E8%A1%8C%E4%B8%9A/">数据分析之金融行业</a><a class="next" href="/2020/12/05/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/">数据分析项目实战</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '',
  clientSecret: '',
  repo: '',
  owner: '',
  admin: [''],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E5%89%8D%E7%AB%AF/">Web前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E5%89%8D%E7%AB%AF/ECMAScript/">ECMAScript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">工具使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/JS%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">JS基础</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/" style="font-size: 15px;">职业规划</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/12/07/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%E9%87%91%E8%9E%8D%E8%A1%8C%E4%B8%9A/">数据分析之金融行业</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/05/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BSQL/">数据分析之SQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/05/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/">数据分析项目实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/06/GitHub+Hexo/">GitHub+Hexo 搭建个人博客网站</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E3%80%81%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E9%97%AD%E5%8C%85%E6%B7%B1%E5%85%A5/">立即执行函数、逗号运算符、闭包</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/24/JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">从JS的数据类型到深拷贝</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">danny's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" color="0,0,0" opacity="0.5" zIndex="-2" count="50" src="//cdn.jsdelivr.net/npm/canvas-nest.js/dist/canvas-nest.min.js"></script><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>